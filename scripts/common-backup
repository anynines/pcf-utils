#!/bin/bash --login

export_opsman_files() {
	ssh-keygen -R $OPS_MANAGER_HOST

	out "common-backup: Exporting deployment manifests"
	/usr/bin/expect -c "
		set timeout -1

		spawn scp $SSH_USER@$OPS_MANAGER_HOST:$1 $2

		expect {
			-re ".*Are.*.*yes.*no.*" {
				send yes\r ;
				exp_continue
			}

			"*?assword:*" {
				send $OPS_MGR_SSH_PASSWORD\r
			}
		}
		expect {
			"*?assword:*" {
				send $OPS_MGR_SSH_PASSWORD\r
				interact
			}
		}

		exit
	"
}

export_root_ca() {
	uaac curl https://$OPS_MANAGER_HOST/api/v0/security/root_ca_certificate -o $WORK_DIR/root_ca_certificate
}

export_installation() {
	if [[ "Y" = "$COMPLETE_BACKUP" || "y" = "$COMPLETE_BACKUP" ]]; then
		CONNECTION_URL=https://$OPS_MANAGER_HOST/api/installation_asset_collection

		out "common-backup: Exporting installation files from: $CONNECTION_URL"
		export UAA_ACCESS_TOKEN=`cat ~/.uaac.yml | grep "access_token:" | cut -d':' -f2 | cut -d' ' -f2`
		# do not use uaac curl as it times out
		curl "$CONNECTION_URL" -X GET -k -H "Authorization: Bearer $UAA_ACCESS_TOKEN" -o $WORK_DIR/installation.zip
	fi
}

export_installation_settings() {
	CONNECTION_URL=https://$OPS_MANAGER_HOST/api/installation_settings

	out "common-backup: Exporting installation.yml and BOSH manifest from: $CONNECTION_URL"
	export UAA_ACCESS_TOKEN=`cat ~/.uaac.yml | grep "access_token:" | cut -d':' -f2 | cut -d' ' -f2`

	curl "$CONNECTION_URL" -X GET -k -H "Authorization: Bearer $UAA_ACCESS_TOKEN" -o $WORK_DIR/installation.yml

	BOSH_MANIFEST_URL=https://$OPS_MANAGER_HOST/api/v0/staged/director/manifest

	curl "$BOSH_MANIFEST_URL" -X GET -k -H "Authorization: Bearer $UAA_ACCESS_TOKEN" -o $DEPLOYMENT_DIR/bosh.yml
}

export_encryption_key() {
	out "common-backup: Exporting DB encryption key"
	grep -E 'db_encryption_key' $WORK_DIR/$CF_DEPLOYMENT_FILE_NAME | cut -d ':' -f 2 | sort -u > $WORK_DIR/cc_db_encryption_key.txt
}

export_bosh_vms() {
	out "common-backup: Exporting BOSH VMs"
	OUTPUT=`bosh vms | grep "cloud_controller[-/]" | awk '{print $2}'`
	echo $OUTPUT > $WORK_DIR/bosh-vms.txt
}

export_cc_db() {
	out "common-backup: Exporting CCDB"
	export_db cf ccdb admin 2544 "ccdb" $DATABASE_DIR/ccdb.sql
}

export_uaadb() {
	out "common-backup: Exporting UAA-DB"
	export_db cf uaadb root 2544 "uaa" $DATABASE_DIR/uaadb.sql
}

export_consoledb() {
	out "common-backup: Exporting CONSOLE-DB"
	export_db cf consoledb root 2544 "console" $DATABASE_DIR/console.sql
}

export_db() {
	out "common-backup: Exporting $@"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb $WORK_DIR/installation.yml credentials $1 $2 $3`

	local USERNAME=`echo $output | cut -d '|' -f 1`
	local PGPASSWORD=`echo $output | cut -d '|' -f 2`
	local IPS=`echo $output | cut -d '|' -f 3`
	local PORT=$4
	local DB=$5
	local DB_FILE=$6

	if [ -n "$IPS" ]; then
		for IP in $IPS; do
			out "common-backup: Export PostgreSQL $DB from $IP"

			pg_dump -h $IP -U $USERNAME -p $PORT -c $DB > $DB_FILE
			if [ $? -eq 0 ]; then
				break
			else
				out "common-backup: ERROR: An error occurred dumping the databases from server $IP"
			fi
		done
	else
		out "common-backup: WARNING: No VM instances found for $DB"
	fi
}

export_mysqldb() {
	out "common-backup: Exporting internal MySQL"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb $WORK_DIR/installation.yml credentials cf mysql root mysql_proxy`

	export USERNAME=`echo $output | cut -d '|' -f 1`
	export PASSWORD=`echo $output | cut -d '|' -f 2`
	export IPS=${MYSQL_HOSTS:-`echo $output | cut -d '|' -f 3 | tr ',' ' '`}

	DB_FILE=$DATABASE_DIR/mysql.sql

	for IP in $IPS; do
		out "common-backup: Exporting MySQL DB from $IP"

		mysqldump -u $USERNAME -p"$PASSWORD" -h $IP --all-databases > $DB_FILE
		if [ $? -eq 0 ]; then
			break
		else
			out "common-backup: ERROR: An error occurred dumping the databases from server $IP"
		fi
	done
}

export_nfs_server() {
	out "common-backup: Exporting file server"

	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb $WORK_DIR/installation.yml credentials cf nfs_server vcap`

	export NFS_SERVER_USER=`echo $output | cut -d '|' -f 1`
	export NFS_SERVER_PASSWORD=`echo $output | cut -d '|' -f 2`
	export NFS_IP=`echo $output | cut -d '|' -f 3`
	while read pattern; do
		export NFS_EXCLUDE="${NFS_EXCLUDE} --exclude=$pattern"
	done < <(echo "$NFS_EXCLUDES")

	ssh-keygen -R $NFS_IP

	/usr/bin/expect -c "
		set timeout -1

		spawn rsync -av $NFS_EXCLUDE $NFS_SERVER_USER@$NFS_IP:/var/vcap/store/shared $NFS_DIR

		expect {
			-re ".*Are.*.*yes.*no.*" {
				send yes\r ;
				exp_continue
			}

			"*?assword:*" {
				send $NFS_SERVER_PASSWORD\r
			}
		}
		expect {
			"*?assword:*" {
				send $NFS_SERVER_PASSWORD\r
				interact
			}
		}

		exit
	"
}

export_director_db(){
	ssh-keygen -R $BOSH_DIRECTOR_VCAP_IP

	out "common-backup: SSHing into Director and dumping DB"
	# UNSET PGPASSWORD DOES NOT WORK
	SCRIPT="\"PGPASSWORD=${DIRECTOR_VCAP_PASSWORD} /var/vcap/packages/postgres/bin/pg_dump -U postgres -c bosh > /var/vcap/store/postgres/pg_log/postgresql.sql; \""

	/usr/bin/expect -c "set timeout -1
		spawn ssh $DIRECTOR_VCAP_USERNAME@$BOSH_DIRECTOR_VCAP_IP $SCRIPT
		expect {
			-re ".*Are.*.*yes.*no.*" {
				send yes\r;
				exp_continue
			}

			"*?assword:*" {
				send $DIRECTOR_VCAP_PASSWORD\r
			}
		}
		expect {
			"*?assword:*" {
				send $DIRECTOR_VCAP_PASSWORD\r
				interact
			}
		}
	exit
	"
}

export_director_store(){
	mkdir -p $WORK_DIR/opsmanager_director
	echo "common-backup: Exporting Director storage"
	/usr/bin/expect -c "set timeout -1
		spawn rsync -v -a --exclude=lost+found $DIRECTOR_VCAP_USERNAME@$BOSH_DIRECTOR_VCAP_IP:/var/vcap/store $WORK_DIR/opsmanager_director
		expect {
			-re ".*Are.*.*yes.*no.*" {
				send yes\r;
				exp_continue
			}
			"*?assword:*" {
				send $DIRECTOR_VCAP_PASSWORD\r
			}
		}
		expect {
			"*?assword:*" {
				send $DIRECTOR_VCAP_PASSWORD\r
				interact
			}
		}
	exit"
}

export_director() {
	if [[ "Y" = "$COMPLETE_BACKUP" || "y" = "$COMPLETE_BACKUP" ]]; then
		out "common-backup: Exporting BOSH Director"
		fetch_director_ssh_credentials

		# detect if multiple directors are present
		grep -q "," <<< $BOSH_DIRECTOR_VCAP_IP
		if [ $? -eq 0 ]; then
			out "Detected multiple directors: $BOSH_DIRECTOR_VCAP_IP"
			local BOSH_DIRECTOR_VCAP_IPS=$(echo "$BOSH_DIRECTOR_VCAP_IP" | tr ',' ' ')
			# choose the first one available
			for IP in $BOSH_DIRECTOR_VCAP_IPS; do
				out "Testing Director: $IP"
				nc -w1 -z $IP 25555
				[ $? -eq 0 ] && export BOSH_DIRECTOR_VCAP_IP=$IP && out "Director is active" && break
			done
		fi

		export_director_db
		export_director_store
	fi
}
