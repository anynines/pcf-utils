#!/bin/bash --login

# include common functions
source common

export_opsman_files() {
	ssh-keygen -R $OPS_MANAGER_HOST

	# replace dollar sign in password with magic for expect
	OPS_MGR_SSH_PASSWORD=$(sed -e 's#\$#\\\$#' <<<$OPS_MGR_SSH_PASSWORD)
	out "common-backup: Exporting deployment manifests"
	/usr/bin/expect -c "
		set timeout -1

		spawn scp $SSH_USER@$OPS_MANAGER_HOST:$1 $2

		expect {
			-re ".*Are.*.*yes.*no.*" {
				send yes\r ;
				exp_continue
			}

			"*?assword:*" {
				send $OPS_MGR_SSH_PASSWORD\r
			}
		}
		expect {
			"*?assword:*" {
				send $OPS_MGR_SSH_PASSWORD\r
				interact
			}
		}

		exit
	"
}

export_root_ca() {
	uaac_curl "https://$OPS_MANAGER_HOST/api/v0/security/root_ca_certificate" "$WORK_DIR/root_ca_certificate" || die $? "Unable to download root CA certificate"
	local output=`ruby ${SCRIPT_BASE:-.}/lib/json_parser.rb "$WORK_DIR/root_ca_certificate" root_ca_certificate_pem`
	echo "$output" > "$WORK_DIR/root_ca_certificate"
	# Alternative: export_opsman_files /var/tempest/workspaces/default/root_ca_certificate $WORK_DIR
	export CA_CERT_LOCATION="$WORK_DIR/root_ca_certificate"
}

export_installation() {
	if [[ "Y" = "$COMPLETE_BACKUP" || "y" = "$COMPLETE_BACKUP" ]]; then
		local CONNECTION_URL="https://$OPS_MANAGER_HOST/api/installation_asset_collection"

		out "common-backup: Exporting installation files from: $CONNECTION_URL"
		# export UAA_ACCESS_TOKEN=`cat ~/.uaac.yml | grep "access_token:" | cut -d':' -f2 | cut -d' ' -f2`
		# curl "$CONNECTION_URL" -X GET -k -H "Authorization: Bearer $UAA_ACCESS_TOKEN" -o $WORK_DIR/installation.zip
		uaac_curl "$CONNECTION_URL" "$WORK_DIR/installation.zip" || die $? "Unable to download installation.zip"
	fi
}

export_installation_settings() {
	out "common-backup: Exporting installation.yml and BOSH manifest from OpsManager"
	# local CONNECTION_URL="https://$OPS_MANAGER_HOST/api/installation_settings"
	# export UAA_ACCESS_TOKEN=`cat ~/.uaac.yml | grep "access_token:" | cut -d':' -f2 | cut -d' ' -f2`
	# curl "$CONNECTION_URL" -X GET -k -H "Authorization: Bearer $UAA_ACCESS_TOKEN" -o $WORK_DIR/installation.yml
	uaac_curl "https://$OPS_MANAGER_HOST/api/installation_settings" installation.yml || die $? "Unable to download installation settings"

	# BOSH_MANIFEST_URL="https://$OPS_MANAGER_HOST/api/v0/staged/director/manifest"
	# curl "$BOSH_MANIFEST_URL" -X GET -k -H "Authorization: Bearer $UAA_ACCESS_TOKEN" -o $DEPLOYMENT_DIR/bosh.yml
	# failing here is not directly an error
	uaac_curl "https://$OPS_MANAGER_HOST/api/v0/staged/director/manifest" "$DEPLOYMENT_DIR/bosh.yml" || out "Unable to download bosh director manifest ($?)"
}

export_encryption_key() {
	out "common-backup: Exporting DB encryption key"
	grep -E 'db_encryption_key' "$WORK_DIR/$CF_DEPLOYMENT_FILE_NAME" | cut -d ':' -f 2 | sort -u > "$WORK_DIR/cc_db_encryption_key.txt"
}

export_bosh_vms() {
	out "common-backup: Exporting BOSH VMs"
	OUTPUT=`bosh vms | grep "cloud_controller[-/]" | awk '{print $2}'`
	echo $OUTPUT > "$WORK_DIR/bosh-vms.txt"
}

export_cc_db() {
	out "common-backup: Exporting CCDB"
	export_db cf ccdb admin 2544 "ccdb" "$DATABASE_DIR/ccdb.sql"
}

export_uaadb() {
	out "common-backup: Exporting UAA-DB"
	export_db cf uaadb root 2544 "uaa" "$DATABASE_DIR/uaadb.sql"
}

export_consoledb() {
	out "common-backup: Exporting CONSOLE-DB"
	export_db cf consoledb root 2544 "console" "$DATABASE_DIR/console.sql"
}

export_db() {
	out "common-backup: Exporting $@"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb "$WORK_DIR/installation.yml" credentials $1 $2 $3`

	local USERNAME=`echo $output | cut -d '|' -f 1`
	local PGPASSWORD=`echo $output | cut -d '|' -f 2`
	local IPS=`echo $output | cut -d '|' -f 3`
	local PORT=$4
	local DB=$5
	local DB_FILE=$6

	if [ -n "$IPS" ]; then
		for IP in $IPS; do
			out "common-backup: Export PostgreSQL $DB from $IP"

			pg_dump -h $IP -U $USERNAME -p $PORT -c $DB > "$DB_FILE"
			if [ $? -eq 0 ]; then
				break
			else
				out "common-backup: ERROR: An error occurred dumping the databases from server $IP"
			fi
		done
	else
		out "common-backup: WARNING: No VM instances found for $DB"
	fi
}

export_mysqldb() {
	out "common-backup: Exporting internal MySQL"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb "$WORK_DIR/installation.yml" credentials cf mysql root mysql_proxy`

	export USERNAME=`echo $output | cut -d '|' -f 1`
	export PASSWORD=`echo $output | cut -d '|' -f 2`
	export IPS=${MYSQL_HOSTS:-`echo $output | cut -d '|' -f 3 | tr ',' ' '`}

	DB_FILE="$DATABASE_DIR/mysql.sql"

	for IP in $IPS; do
		out "common-backup: Exporting MySQL DB from $IP"

		mysqldump -u $USERNAME -p"$PASSWORD" -h $IP --single-transaction --routines --triggers --all-databases > "$DB_FILE"
		if [ $? -eq 0 ]; then
			break
		else
			out "common-backup: ERROR: An error occurred dumping the databases from server $IP"
		fi
	done
}

export_nfs_server() {
	out "common-backup: Exporting file server"

	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb "$WORK_DIR/installation.yml" credentials cf nfs_server vcap`

	export NFS_SERVER_USER=`echo $output | cut -d '|' -f 1`
	export NFS_SERVER_PASSWORD=`echo $output | cut -d '|' -f 2`
	export NFS_IP=`echo $output | cut -d '|' -f 3`
	while read pattern; do
		export NFS_EXCLUDE="${NFS_EXCLUDE} --exclude=$pattern"
	done < <(echo "$NFS_EXCLUDES")

	ssh-keygen -R $NFS_IP

	/usr/bin/expect -c "
		set timeout -1

		spawn rsync -av $NFS_EXCLUDE $NFS_SERVER_USER@$NFS_IP:/var/vcap/store/shared "$NFS_DIR"

		expect {
			-re ".*Are.*.*yes.*no.*" {
				send yes\r ;
				exp_continue
			}

			"*?assword:*" {
				send $NFS_SERVER_PASSWORD\r
			}
		}
		expect {
			"*?assword:*" {
				send $NFS_SERVER_PASSWORD\r
				interact
			}
		}

		exit
	"
}

export_director_db(){
	out "common-backup: dumping Director DB"
	bosh backup "$WORK_DIR/opsmanager_director/db.tgz"
}

export_director_store(){
	mkdir -p "$WORK_DIR/opsmanager_director"
	echo "common-backup: Exporting Director storage"
	/usr/bin/expect -c "set timeout -1
		spawn rsync -v -a --exclude=lost+found $DIRECTOR_VCAP_USERNAME@$BOSH_DIRECTOR_VCAP_IP:/var/vcap/store "$WORK_DIR/opsmanager_director"
		expect {
			-re ".*Are.*.*yes.*no.*" {
				send yes\r;
				exp_continue
			}
			"*?assword:*" {
				send $DIRECTOR_VCAP_PASSWORD\r
			}
		}
		expect {
			"*?assword:*" {
				send $DIRECTOR_VCAP_PASSWORD\r
				interact
			}
		}
	exit"
}

export_director() {
	if [[ "Y" = "$COMPLETE_BACKUP" || "y" = "$COMPLETE_BACKUP" ]]; then
		out "common-backup: Exporting BOSH Director"
		fetch_director_ssh_credentials

		# detect if multiple directors are present
		grep -q "," <<< $BOSH_DIRECTOR_VCAP_IP
		if [ $? -eq 0 ]; then
			out "Detected multiple directors: $BOSH_DIRECTOR_VCAP_IP"
			local BOSH_DIRECTOR_VCAP_IPS=$(echo "$BOSH_DIRECTOR_VCAP_IP" | tr ',' ' ')
			# choose the first one available
			for IP in $BOSH_DIRECTOR_VCAP_IPS; do
				out "Testing Director: $IP"
				nc -w1 -z $IP 25555
				[ $? -eq 0 ] && export BOSH_DIRECTOR_VCAP_IP=$IP && out "Director is active" && break
			done
		fi

		export_director_db
		export_director_store
	fi
}
