#!/bin/bash --login

export REQUIRED="bosh
curl
expect
mysqldump
pg_dump
rsync
ruby
scp
uaac"

# Write out text in an unified manner to stderr (because we don't want to be
# part of the output if we parse or use the output in a variable).
function out() {
	echo "$(date) $SCRIPTNAME[$$]: ${1+$@}" 1>&2
}

# Call this on error and it will exit with the given exit code and the message.
# Usage: die [exitcode] message
function die() {
	# is return code explicitly given?
	echo "$1" | grep -E -q "^[[:digit:]]+$"
	if [ $? -ne 0 ]; then
		# if not, use generic "1"
		retcode=1
	else
		# if so, use it and shift arguments by one
		retcode=${1:-1}
		shift
	fi
	# echo message in unified format and exit
	out "${1+$@} (Exit Code: $retcode)"
	exit $retcode
}

require_binary() {
	local bin="$1"
	if [ -z "$bin" ]; then
		out "common: WARNING: 'require' not used properly. Please specify an argument."
		return 0
	fi

	local filepath=$(which "$bin" 2>/dev/null)
	if [ -z "$filepath" ]; then
		out "common: $1 not installed"
		return 1
	fi
}

validate_software() {
	local ret=0

	out "common: Validating mandatory tools"
	while read bin; do
		require_binary $bin || ret=1
	done <<< "$REQUIRED"

	if [ $ret -eq 0 ]; then
		out "common: Validations DONE"
	else
		die "common: ERROR: Validations FAILED"
	fi
}

prepare_backup() {
	out "common: Preparing Backup"
	local ret=0
	mkdir -p "$WORK_DIR" || ret=1
	mkdir -p "$NFS_DIR" || ret=1
	mkdir -p "$DEPLOYMENT_DIR" || ret=1
	mkdir -p "$DATABASE_DIR" || ret=1
	if [ $ret -eq 0 ]; then
		out "common: Preparations DONE"
	else
		die "common: ERROR: Preparations FAILED"
	fi
}

login_opsman() {
	out "common: Remove the old uaa authentication tokens"
	rm ~/.uaac.yml

	out "common: Login to OpsManager"
	uaac target https://$OPS_MANAGER_HOST/uaa --skip-ssl-validation || die $? "Unable to target UAA"
	uaac token owner get opsman $OPS_MGR_ADMIN_USERNAME -s "" -p $OPS_MGR_ADMIN_PASSWORD || die $? "Unable to login to UAA"
	export UAA_ACCESS_TOKEN=`cat ~/.uaac.yml | grep "access_token:" | cut -d':' -f2 | cut -d' ' -f2`
}

uaac_curl() {
	# do not use "uaac curl" directly as it times out
	# UAA_ACCESS_TOKEN is used (login_opsman has to be called in advance)
	local CONNECTION_URL=$1
	local OUTPUT=${2#$WORK_DIR/}
	curl "$CONNECTION_URL" -X GET -k -H "Authorization: Bearer $UAA_ACCESS_TOKEN" -o "$WORK_DIR/$OUTPUT"
	return $?
}

fetch_mysql_credentials() {
	out "common: Fetching MySQL credentials"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb "$WORK_DIR/installation.yml" credentials p-mysql mysql root 2>/dev/null`
	export PMYSQL_USER=`echo $output | cut -d '|' -f 1`
	export PMYSQL_PASS=`echo $output | cut -d '|' -f 2`
	export PMYSQL_HOSTS=${PMYSQL_HOSTS:-`echo $output | cut -d '|' -f 3 | sed 's/,/ /g'`}
	if [ -z "$PMYSQL_USER" -a -z "$PMYSQL_PASS" -a -z "$PMYSQL_HOSTS" ]; then
		die "common: ERROR: Either PMYSQL_USER, PMYSQL_PASS or PMYSQL_HOSTS is empty"
	fi
}

fetch_rabbitmq_credentials() {
	out "common: Fetching RabbitMQ credentials"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb "$WORK_DIR/installation.yml" credentials p-rabbitmq rabbitmq-server admin 2>/dev/null`
	export RABBITMQ_USER=`echo $output | cut -d '|' -f 1`
	export RABBITMQ_PASS=`echo $output | cut -d '|' -f 2`
	if [ -z "$RABBITMQ_USER" -a -z "$RABBITMQ_PASS" ]; then
		die "common: ERROR: Either RABBITMQ_USER, RABBITMQ_PASS is empty"
	fi
}

fetch_redis_credentials() {
	out "common: Fetching Redis credentials"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb "$WORK_DIR/installation.yml" credentials p-redis cf-redis-broker vcap 2>/dev/null`
	export REDIS_USER=`echo $output | cut -d '|' -f 1`
	export REDIS_PASS=`echo $output | cut -d '|' -f 2`
	export REDIS_HOST=`echo $output | cut -d '|' -f 3`
	if [ -z "$REDIS_USER" -a -z "$REDIS_PASS" -a -z "$REDIS_HOSTS" ]; then
		die "common: ERROR: Either REDIS_USER, REDIS_PASS or REDIS_HOSTS is empty"
	fi
}

fetch_director_ssh_credentials(){
	out "common: Fetching BOSH Director VM credentials"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb "$WORK_DIR/installation.yml" credentials p-bosh director vcap`
	export DIRECTOR_VCAP_USERNAME=`echo $output | cut -d '|' -f 1`
	export DIRECTOR_VCAP_PASSWORD=`echo $output | cut -d '|' -f 2`
	export BOSH_DIRECTOR_VCAP_IP=`echo $output | cut -d '|' -f 3`
	if [ -z "$DIRECTOR_VCAP_USERNAME" -a -z "$DIRECTOR_VCAP_PASSWORD" -a -z "$BOSH_DIRECTOR_VCAP_IP" ]; then
		die "common: ERROR: Either DIRECTOR_VCAP_USERNAME, DIRECTOR_VCAP_PASSWORD or BOSH_DIRECTOR_VCAP_IP is empty"
	fi
}

fetch_bosh_connection_parameters() {
	out "common: Fetching BOSH Director credentials"
	output=`ruby ${SCRIPT_BASE:-.}/lib/installationparser/app.rb "$WORK_DIR/installation.yml" credentials p-bosh director director`
	export DIRECTOR_USERNAME=`echo $output | cut -d '|' -f 1`
	export DIRECTOR_PASSWORD=`echo $output | cut -d '|' -f 2`
	export BOSH_DIRECTOR_IP=`echo $output | cut -d '|' -f 3`
	if [ -z "$DIRECTOR_USERNAME" -a -z "$DIRECTOR_PASSWORD" -a -z "$BOSH_DIRECTOR_IP" ]; then
		die "common: ERROR: Either DIRECTOR_USERNAME, DIRECTOR_PASSWORD or BOSH_DIRECTOR_IP is empty"
	fi

}

bosh_status() {
	out "common: Fetching BOSH status"
	bosh status > "$WORK_DIR/bosh_status.txt"
	export BOSH_UUID=`grep UUID "$WORK_DIR/bosh_status.txt" | cut -d 'D' -f 2 | tr -d ' ' | sort -u`

	export UUID_EXISTS=`grep -Fxq $BOSH_UUID "$WORK_DIR/$CF_DEPLOYMENT_FILE_NAME"`
	if [[ -z $UUID_EXISTS ]]; then
		out "common: UUID Matches"
	else
		die "common: ERROR: UUID Mismatch"
	fi

	rm -rf "$WORK_DIR/bosh_status.txt"
}

bosh_target() {
	local director_ip=$1
	out "common: Targeting Director '$director_ip'"

	if [ "${BOSH_OLD_CLI:-false}" == "true" ]; then
		PRE_TARGET_PARAM=""
		POST_TARGET_PARAM="--ca-cert $CA_CERT_LOCATION"
	else
		PRE_TARGET_PARAM="--ca-cert $CA_CERT_LOCATION"
		POST_TARGET_PARAM=""
	fi

	output=$(/usr/bin/expect -c "
		set timeout -1

		spawn bosh $PRE_TARGET_PARAM target $POST_TARGET_PARAM $director_ip

		expect {
			-re \".*Email:*\" {
				send $DIRECTOR_USERNAME\r ;
				exp_continue
			}

			\"*?assword:*\" {
				send $DIRECTOR_PASSWORD\r
				interact
			}
		}" 2>&1)
	grep -qs "^Failed to login" <<<"$output"
	ret=$?
	echo "$output"

	if [ $ret -ne 0 ]; then
		out "common: Director targeted"
	else
		die "common: ERROR: Could not target director '$director_ip'"
	fi
}

bosh_login() {
	out "common: Login into BOSH"
	rm -rf ~/.bosh_config

	# detect if multiple directors are present
	grep -q "," <<< $BOSH_DIRECTOR_IP
	if [ $? -eq 0 ]; then
		out "Detected multiple directors: $BOSH_DIRECTOR_IP"
		local BOSH_DIRECTOR_IPS=$(echo "$BOSH_DIRECTOR_IP" | tr ',' ' ')
		# target the first one available
		for IP in $BOSH_DIRECTOR_IPS; do
			bosh_target $IP && break
		done
	else
		bosh_target $BOSH_DIRECTOR_IP  || die $? "Unable to target director"
	fi
}

bosh_login_wo_certs() {
	out "common: Login into BOSH without certificates"
	rm -rf ~/.bosh_config

	out "DIRECTOR IP: $BOSH_DIRECTOR_IP"

	/usr/bin/expect -c "
		set timeout -1

		spawn bosh target $BOSH_DIRECTOR_IP

		expect {
			-re ".*username:*" {
				send $DIRECTOR_USERNAME\r ;
				exp_continue
			}

			"*?assword:*" {
				send $DIRECTOR_PASSWORD\r
				interact
			}
		}

		exit
	"
	if [ $? -eq 0 ]; then
		out "common: Director targeted"
	else
		die "common: ERROR: Could not target director '$director_ip'"
	fi
}

set_bosh_deployment() {
	out "common: Setting deployment"
	bosh deployment "$WORK_DIR/$CF_DEPLOYMENT_FILE_NAME"  || die $? "Unable to set deployment to '$CF_DEPLOYMENT_FILE_NAME'"
}

logout_all() {
	out "common: Performing logout"
	bosh logout
	uaac token delete "$OPS_MGR_ADMIN_USERNAME"
}

stop_cloud_controller() {
	out "common: Stopping all Cloud Controller"
	OUTPUT=`cat "$WORK_DIR/bosh-vms.txt"`

	for word in $OUTPUT; do
		out "common: Stopping '$word'"
		JOB=`echo $word | cut -d '/' -f 1`
		INDEX=`echo $word | cut -d '/' -f 2`

		bosh -n stop $JOB $INDEX --force
	done
}

start_cloud_controller() {
	out "common: Starting all Cloud Controller"
	OUTPUT=`cat "$WORK_DIR/bosh-vms.txt"`

	for word in $OUTPUT
	do
		out "common: Starting '$word'"
		JOB=`echo $word | cut -d '/' -f 1`
		INDEX=`echo $word | cut -d '/' -f 2`

		bosh -n start $JOB $INDEX --force
	done
}

verify_deployment_backedUp() {
	out "common: Verifying CF deployment manifest"
	export CF_DEPLOYMENT_NAME=`bosh deployments | grep "cf-" | cut -d '|' -f 2 | tr -s ' ' | grep "cf-" | tr -d ' ' | head -1`
	export CF_DEPLOYMENT_FILE_NAME=$CF_DEPLOYMENT_NAME.yml

	out "common: Looking for manifest '$CF_DEPLOYMENT_NAME', file name '$CF_DEPLOYMENT_FILE_NAME'"

	if [ -f "$WORK_DIR/$CF_DEPLOYMENT_FILE_NAME" ]; then
		out "common: File exists"
	else
		out "common: File does not exist. Downloading."
		bosh download manifest $CF_DEPLOYMENT_NAME "$WORK_DIR/$CF_DEPLOYMENT_FILE_NAME"
	fi
}

zip_all_together() {
	out "common: Compressing backup into '$BACKUP_DIR_NAME.tar.gz'"
	cd "$WORK_DIR"
	cd ..
	tar -zcvf "$BACKUP_DIR_NAME.tar.gz" "$BACKUP_DIR_NAME"
	if [ $? -eq 0 ]; then
		out "common: Compression SUCCESSFUL. Removing working directory."
		rm -rf "$WORK_DIR"
	else
		out "common: Compression FAILED. Leaving working directory as-is."
		return 1
	fi
}
