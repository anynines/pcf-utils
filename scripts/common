#!/bin/bash --login

export REQUIRED="bosh
curl
expect
mysqldump
pg_dump
rsync
ruby
uaac"

out() {
	echo "$(date) $SCRIPTNAME[$$]: ${1+$@}" 1>&2
}

require_binary() {
	local bin="$1"
	if [ -z "$bin" ]; then
		out "Warning: 'require' not used properly. Please specify an argument."
		return 0
	fi

	local filepath=$(which "$bin" 2>/dev/null)
	if [ -z "$filepath" ]; then
		out "$1 not installed"
		return 1
	fi
}

validate_software() {
	local ret=0

	out "Checking for mandatory tools"
	while read bin; do
		require_binary $bin || ret=1
	done <<< "$REQUIRED"

	if [ $ret -eq 0 ]; then
		out "Validations DONE"
	else
		out "ERROR: Validations FAILED"
		exit 1
	fi
}


login_opsman() {

	out "Remove the old uaa authentication tokens"
	rm ~/.uaac.yml

	out "LOGIN TO OPSMAN"

	uaac target https://$OPS_MANAGER_HOST/uaa --skip-ssl-validation

	uaac token owner get opsman $OPS_MGR_ADMIN_USERNAME -s "" -p $OPS_MGR_ADMIN_PASSWORD
}

fetch_director_ssh_credentials(){
	out "GATHER BOSH DIRECTOR VCAP CONNECTION PARAMETERS"

	output=`ruby lib/installationparser/app.rb $WORK_DIR/installation.yml p-bosh director vcap`

	export DIRECTOR_VCAP_USERNAME=`echo $output | cut -d '|' -f 1`
	export DIRECTOR_VCAP_PASSWORD=`echo $output | cut -d '|' -f 2`
	export BOSH_DIRECTOR_VCAP_IP=`echo $output | cut -d '|' -f 3`
}

fetch_bosh_connection_parameters() {
	out "GATHER BOSH DIRECTOR CONNECTION PARAMETERS"

	output=`ruby lib/installationparser/app.rb $WORK_DIR/installation.yml p-bosh director director`

	export DIRECTOR_USERNAME=`echo $output | cut -d '|' -f 1`
	export DIRECTOR_PASSWORD=`echo $output | cut -d '|' -f 2`
	export BOSH_DIRECTOR_IP=`echo $output | cut -d '|' -f 3`
}

bosh_status() {
	out "EXECUTE BOSH STATUS"
	bosh status > $WORK_DIR/bosh_status.txt
	export BOSH_UUID=`grep UUID $WORK_DIR/bosh_status.txt | cut -d 'D' -f 2 | tr -d ' ' | sort -u`

	export UUID_EXISTS=`grep -Fxq $BOSH_UUID $WORK_DIR/$CF_DEPLOYMENT_FILE_NAME`
	if [[ -z $UUID_EXISTS ]]; then
		out "UUID Matches"
	else
		out "UUID Mismatch"
		exit 1
	fi

	rm -rf $WORK_DIR/bosh_status.txt
}

bosh_target() {
	local director_ip=$1
	out "DIRECTOR IP: $director_ip"

	if [ "${BOSH_OLD_CLI:-false}" == "true" ]; then
		PRE_TARGET_PARAM=""
		POST_TARGET_PARAM="--ca-cert $CA_CERT_LOCATION"
	else
		PRE_TARGET_PARAM="--ca-cert $CA_CERT_LOCATION"
		POST_TARGET_PARAM=""
	fi

	/usr/bin/expect -c "
		set timeout -1

		spawn bosh $PRE_TARGET_PARAM target $POST_TARGET_PARAM $director_ip

		expect {
			-re ".*Email:*" {
				send $DIRECTOR_USERNAME\r ;
				exp_continue
			}

			"*?assword:*" {
				send $DIRECTOR_PASSWORD\r
				interact
			}
		}

		exit
	"
	return $?
}

bosh_login() {
	out "BOSH LOGIN"
	rm -rf ~/.bosh_config

	# detect if multiple directors are present
	grep -q "," <<< $BOSH_DIRECTOR_IP
	if [ $? -eq 0 ]; then
		out "Detected multiple directors: $BOSH_DIRECTOR_IP"
		local BOSH_DIRECTOR_IPS=$(echo "$BOSH_DIRECTOR_IP" | tr ',' ' ')
		# target the first one available
		for IP in $BOSH_DIRECTOR_IPS; do
			bosh_target $IP && break
		done
	else
		bosh_target $BOSH_DIRECTOR_IP
	fi
}

bosh_login_wo_certs() {
	out "BOSH LOGIN"
	rm -rf ~/.bosh_config

	out "DIRECTOR IP: $BOSH_DIRECTOR_IP"

	/usr/bin/expect -c "
		set timeout -1

		spawn bosh target $BOSH_DIRECTOR_IP

		expect {
			-re ".*username:*" {
				send $DIRECTOR_USERNAME\r ;
				exp_continue
			}

			"*?assword:*" {
				send $DIRECTOR_PASSWORD\r
				interact
			}
		}

		exit
	"
}

set_bosh_deployment() {
	out "SET THE BOSH DEPLOYMENT"
	bosh deployment $WORK_DIR/$CF_DEPLOYMENT_FILE_NAME
}

logout_all() {
	bosh logout
	uaac token delete $OPS_MGR_ADMIN_USERNAME
}

stop_cloud_controller() {
	out "STOPPING CLOUD CONTROLLER"
	OUTPUT=`cat $WORK_DIR/bosh-vms.txt`

	for word in $OUTPUT; do
		JOB=`echo $word | cut -d '/' -f 1`
		INDEX=`echo $word | cut -d '/' -f 2`

		bosh -n stop $JOB $INDEX --force
	done
}

start_cloud_controller() {
	out "STARTING CLOUD CONTROLLER"
	OUTPUT=`cat $WORK_DIR/bosh-vms.txt`

	for word in $OUTPUT
	do
		JOB=`echo $word | cut -d '/' -f 1`
		INDEX=`echo $word | cut -d '/' -f 2`

		bosh -n start $JOB $INDEX --force
	done
}

verify_deployment_backedUp() {
	out "VERIFY CF DEPLOYMENT MANIFEST"
	export CF_DEPLOYMENT_NAME=`bosh deployments | grep "cf-" | cut -d '|' -f 2 | tr -s ' ' | grep "cf-" | tr -d ' ' | head -1`
	export CF_DEPLOYMENT_FILE_NAME=$CF_DEPLOYMENT_NAME.yml

	out "FILES LOOKING FOR $CF_DEPLOYMENT_NAME $CF_DEPLOYMENT_FILE_NAME"

	if [ -f $WORK_DIR/$CF_DEPLOYMENT_FILE_NAME ]; then
		out "file exists"
	else
		out "file does not exist"
		bosh download manifest $CF_DEPLOYMENT_NAME $WORK_DIR/$CF_DEPLOYMENT_FILE_NAME
	fi
}

zip_all_together() {
	cd $WORK_DIR
	cd ..
	cmd=`tar -zcvf $BACKUP_DIR_NAME.tar.gz $BACKUP_DIR_NAME`
	out "Compressed the backup into $BACKUP_DIR_NAME.tar.gz"
	cmd=`rm -rf $WORK_DIR`
}

prepare() {
	out "Preparing Backup"
	local ret=0
	mkdir -p "$WORK_DIR" || ret=1
	mkdir -p "$NFS_DIR" || ret=1
	mkdir -p "$DEPLOYMENT_DIR" || ret=1
	mkdir -p "$DATABASE_DIR" || ret=1
	if [ $ret -eq 0 ]; then
		out "Preparations DONE"
	else
		out "ERROR: Preparations FAILED"
		exit 1
	fi
}
